// Generated by LiveScript 1.3.1
var outputDefaultOptions, inputDefaultOptions, fromArray, fromJson, dataValidate, compute;
outputDefaultOptions = {
  sort: false
};
inputDefaultOptions = {
  isRowBased: true,
  isRank: false,
  higherIsBetter: true
};
fromArray = function(data, options){
  var rank, ref$, candidateNames, judgeNames, score, j, i, i$, to$;
  options == null && (options = {});
  options = import$(import$({}, inputDefaultOptions), options);
  rank = {};
  ref$ = [
    data.map(function(it){
      return it[0];
    }), JSON.parse(JSON.stringify(data[0]))
  ].map(function(it){
    return it.slice(1, it.length);
  }), candidateNames = ref$[0], judgeNames = ref$[1];
  if (!options.isRowBased) {
    ref$ = [judgeNames, candidateNames], candidateNames = ref$[0], judgeNames = ref$[1];
  }
  score = options.isRowBased
    ? (function(){
      var i$, to$, lresult$, j$, to1$, results$ = [];
      for (i$ = 1, to$ = data[0].length; i$ < to$; ++i$) {
        j = i$;
        lresult$ = [];
        for (j$ = 1, to1$ = data.length; j$ < to1$; ++j$) {
          i = j$;
          lresult$.push(data[i][j]);
        }
        results$.push(lresult$);
      }
      return results$;
    }())
    : (function(){
      var i$, to$, lresult$, j$, to1$, results$ = [];
      for (i$ = 1, to$ = data.length; i$ < to$; ++i$) {
        i = i$;
        lresult$ = [];
        for (j$ = 1, to1$ = data[0].length; j$ < to1$; ++j$) {
          j = j$;
          lresult$.push(data[i][j]);
        }
        results$.push(lresult$);
      }
      return results$;
    }());
  for (i$ = 0, to$ = judgeNames.length; i$ < to$; ++i$) {
    i = i$;
    rank[judgeNames[i]] = score[i];
  }
  dataValidate(rank, options);
  return compute({
    rank: rank,
    candidateNames: candidateNames,
    judgeNames: judgeNames
  });
};
fromJson = function(json, options){
  var rank, candidateNames, judgeNames, res$, k;
  options == null && (options = {});
  options = import$(import$({}, inputDefaultOptions), options);
  rank = json.rank;
  candidateNames = json.candidateNames;
  res$ = [];
  for (k in json.rank) {
    res$.push(k);
  }
  judgeNames = res$;
  dataValidate(rank, options);
  return compute({
    rank: rank,
    candidateNames: candidateNames,
    judgeNames: judgeNames
  });
};
dataValidate = function(rank, options){
  var judge, list, i$, to$, i, value, results$ = [];
  for (judge in rank) {
    list = rank[judge];
    for (i$ = 0, to$ = list.length; i$ < to$; ++i$) {
      i = i$;
      value = list[i];
      if (isNaN(value)) {
        console.log("warning: '" + value + "' is type NaN (" + (i + 1) + "th element for " + judge + ")");
      }
      list[i] = +value;
    }
    results$.push(rank[judge] = list.map(fn$));
  }
  return results$;
  function fn$(v){
    var ret;
    if (isNaN(v)) {
      return v;
    }
    ret = list.filter(function(it){
      if (options.higherIsBetter) {
        return it > v;
      } else {
        return it < v;
      }
    });
    return ret.length + 1;
  }
};
compute = function(arg$){
  var rank, candidateNames, judgeNames, data, judges, res$, k, size, d, i$, i, lresult$, j$, j, p, lresult1$, len$, judge, k$, a, b, hash, count, sum, list, v, ref$;
  rank = arg$.rank, candidateNames = arg$.candidateNames, judgeNames = arg$.judgeNames;
  data = rank;
  res$ = [];
  for (k in data) {
    res$.push(k);
  }
  judges = res$;
  size = data[judges[0]].length;
  res$ = [];
  for (i$ = 0; i$ < size; ++i$) {
    i = i$;
    lresult$ = [];
    for (j$ = 0; j$ < size; ++j$) {
      j = j$;
      lresult$.push(0);
    }
    res$.push(lresult$);
  }
  d = res$;
  res$ = [];
  for (i$ = 0; i$ < size; ++i$) {
    i = i$;
    lresult1$ = [];
    for (j$ = 0; j$ < size; ++j$) {
      j = j$;
      lresult1$.push(0);
    }
    res$.push(lresult1$);
  }
  p = res$;
  for (i$ = 0, len$ = judges.length; i$ < len$; ++i$) {
    judge = judges[i$];
    rank = data[judge];
    for (j$ = 0; j$ < size; ++j$) {
      i = j$;
      for (k$ = 0; k$ < size; ++k$) {
        j = k$;
        if (rank[i] < rank[j]) {
          d[i][j]++;
        }
      }
    }
  }
  for (i$ = 0; i$ < size; ++i$) {
    i = i$;
    for (j$ = 0; j$ < size; ++j$) {
      j = j$;
      if (i === j) {
        continue;
      }
      if (d[i][j] > d[j][i]) {
        p[i][j] = d[i][j];
      } else {
        p[i][j] = 0;
      }
    }
  }
  for (i$ = 0; i$ < size; ++i$) {
    i = i$;
    for (j$ = 0; j$ < size; ++j$) {
      j = j$;
      if (i === j) {
        continue;
      }
      for (k$ = 0; k$ < size; ++k$) {
        k = k$;
        if (i === k || j === k) {
          continue;
        }
        p[j][k] = Math.max(p[j][k], Math.min(p[j][i], p[i][k]));
      }
    }
  }
  for (i$ = 0; i$ < size; ++i$) {
    i = i$;
    for (j$ = 0; j$ < size; ++j$) {
      j = j$;
      a = p[i][j];
      b = p[j][i];
    }
  }
  rank = [];
  hash = {};
  for (i$ = 0; i$ < size; ++i$) {
    i = i$;
    count = 0;
    for (j$ = 0; j$ < size; ++j$) {
      j = j$;
      if (p[i][j] > 0) {
        count++;
      }
    }
    if (hash[count] != null) {
      hash[count].count++;
    } else {
      hash[count] = {
        count: 1,
        rank: 0
      };
    }
    rank.push({
      idx: i,
      count: count
    });
  }
  rank.sort(function(a, b){
    return b.count - a.count;
  });
  sum = 1;
  res$ = [];
  for (k in hash) {
    v = hash[k];
    res$.push([k, v]);
  }
  list = res$;
  list.sort(function(a, b){
    return b[0] - a[0];
  });
  for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
    ref$ = list[i$], k = ref$[0], v = ref$[1];
    v.rank = sum;
    sum += v.count;
  }
  rank.map(function(d, i){
    d.rank = hash[d.count].rank;
    return d.name = candidateNames[d.idx];
  });
  return rank;
};
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}